Flow control instructions (aka jumps).
=======================================


  Well, let's talk today about the jump instruction family.  I have
named this doc 'flow control instructions' mainly because I did not
find a better name :P, but what does 'flow control' mean?  CPUs are
basically designed to execute code sequentially: the instructions are
ordered in memory and each instruction is executed after the
instruction which is before, and before the instruction which is
located next.  The order in which instructions are executed is called
the flow of execution.

  Of course a sequential flow of execution is very limited, so here is
where flow control instructions come.  These instructions modify the
flow of execution telling the CPU which instruction will be the next
to be executed, rather than just execute the instruction next in
memory, as it is done by default.  There are many kinds of flow control
instructions and we will see some of them here.

  But why must the flow of execution change?  There are many reasons
that in determine each kind of flow control instruction.  One of
the main reasons is to decide what code will be executed next.  The
instructions which make these decisions are usually called conditional
jump or branch instructions.  Another of the reasons is because the same
piece of code can be executed many times.  It is not usually a good idea
to replicate that code as many times as it is executed.  So the code is
organized in loops and functions (and/or procedures).  The instructions
which perform these tasks are called unconditional jumps, call to
function, return.

  Some CPUs have two (or even more) working modes, a user mode for
common programs and a protected or system mode for the OS.  To gain
access to the OS functions (system calls) some CPUs have special
instructions, they are usually called software interrupts, traps,
gates.

  There is a way to break the flow of execution without executing any
instruction.  CPUs provide facilities so the hardware devices can send
signals to the CPU.  These signals are called hardware interrupts (or
just interrupts, also IRQs).  When a hardware interrupt is received
(and interrupts are enabled) the CPU breaks the execution flow and
starts to execute the code from a fixed (or vector driven) address.
When this code ends it executes a special returning instruction
(interrupt return or iret) and the execution is continued at the point
it was stopped.  We need to take into account this behaviour when
doing our emulator.

  There is another kind of interrupt which is internal to the CPU,
they are called exceptions.  An exception breaks the execution of an
instruction.  It doesn't even wait the end of the instruction as an
IRQ does, because the exceptions are generated by errors in the
execution of the instruction.  Not all CPUs generate exceptions, but
the modern CPUs usually provide them.  The more common examples of
exception are the divide by zero exception and the memory exception
(or page fault).  This last one is very important for systems with
virtual memory support.  When the handling routine for the exception
ends it returns to the same instruction that was being executed (and
this time it should work correctly ;).

  I think I will talk further about interrupts (mainly) and exceptions
in another doc.

  The flow of execution in a CPU is driven by a register usually
called the PC (program counter) which points to the next instruction
to be executed.  This means that what a flow control instructions have
to do is basically to change the PC.  In a proper way of course ;).

  I will start with the jump instructions.  A jump, or sometimes also
called branch, just changes the PC register (and it does nothing
more).  There are basically two possible changes: to add or sub a
number to the PC, this is then a relative to PC jump, or it just
loads the PC with a new value, and then it is an absolute jump.  There
is just another minor distinction between jumps in some CPUs: far and
near jumps.  Absolute jumps are always far jumps, but relatives can be
sometimes near or far.  A near jump has a smaller range of address to
jump to than a far jump.

  Often the jump target address is near to the address of the
jump instruction (small loops, ifs, etc.).  It makes sense to have a
smaller instruction (to save in code size or even because the instruction
size is limited) for those jumps, for example a jump with just a byte
for the offset.  For larger jumps we can use an absolute jump or a
far jump (if available) which has a larger offset.

  A relative jump offsets the PC, so the first thing to do when
emulating it is to sign extend the offset value (a byte or a word) to
the size of the PC and add to the PC this sign extended value.

  An absolute jump is just a load into the PC.  The value to load can
be an immediate value (the target address is stored in the same
instruction) or a value stored in memory or in a register.

  A jump can also be conditional.  A conditional jump is a jump which
only performs the jump if a given condition is satisfied.  For example
if flag Z is 0.  Conditional jumps used to be always relative (and many
time just near) jumps, because they are used in small loops and for
building ifs (an if C statement is usually assembled as a
concatenation of conditional jumps).  For emulating a conditional jump
the first thing to do is to check the condition, if the condition is
satisfied the PC is changed as in a normal (unconditional) jump, if
the condition is not satisfied there is not a jump.  The PC is just
updated to execute the instruction next to the jump as in a common
instruction.

  The i8080 has only absolute jump instructions (it is really strange
but it doesn't have relative conditinal jumps, which are quite common
in 8-bit CPUs, the Z80 has them though).  It has two unconditinal
jumps: JP and PCHL.  PCHL loads the content of the HL register into
the PC (useful for indirect jumps as used in jump tables).  There are
8 conditional jumps too, depending upon the value of 4 of the i8080
flags (Z, C, P and S).

  For example a JC (jump if carry is set) instruction should be
emulated this way:

	case 0xDA:
		if (F & CFlag)	//	Test if the Carry flags is set
			pc = memory[pc];	// Load PC with the jump address
		else
			pc += 2; 	// Not set, skip address, next instr.
		break;


  Some CPUs have a nasty feature: delayed jumps.  A delayed jump means
that the instruction (or n instructions) next to the jump instruction
are executed always (as they were before the jump but without
modifying the condition).  That is hard to explain but it is because
the CPUs are pipelined (search a book about computer architecture) and
jumps are a real nightmare for performance.  Jumps break the flow of
execution and that breaks the pipelining too.  To solve this problem
some CPUs use this solution. Other just try to do a good jump
prediction (Pentium).  In such a CPU this feature is very important to
be emulated too.

  Jumps are used for controlling the flow of execution inside a
function, creating loops or implementing if and switch statements.
But there is another kind of flow control instructions which are used
to control the flow between functions.  They are the call and the ret
instruction (sometimes they have other names).  A call jumps to a new
function, a ret returns from a function.

  What is the difference with a jump instruction?  A jump instruction
just performs the jump and then (unless the programmer implements it
by hand) there is no way to return to the point the jump was made. This
would be a useful feature because that is what a function does.  A
function is called, it executes its code and when it ends, it is supposed
to return to the point it was called and continue the execution there.
The call and ret instructions implement this feature for the programmer.

  The first thing a call does is to store the returning address.
Where does it store it?  Do you remember the stack?  Well, the main
purpose of the stack is to store the return addresses for function
calls.  If you look to how a stack works, it is the way the return
addresses have to be stored, the more recent called functions will be
the first functions to return.

  So a call stores the PC for the next instruction (the actual PC) in
the stack (in the position pointed by the SP register), updates the SP
(if the stack goes from high to low address, as is usual, it is
subtracted the size of an address value) and then loads the PC with
the address for the called function.  The address for the called
function is an absolute value which can be immediate (in the same
instruction) or indirect (in memory or in a register).

  The ret instruction does the opposite task.  When a function ends
it does a ret instruction.  The ret gets the value in the last entry
of the stack and loads it into the PC.  Then updates the SP, adding
the size of an address value (high to low stack).  In some CPUs the
ret function also adds a given value to the SP (the stack frame for
the function).

  The stack is also used by the functions to store the parameters
passed to the function and the results of the function (when the
calling conventions make them to go through the stack), and any other
temporal data related to a function (local variables).  When a
function ends it has also to free all the space in the stack it has
used.  That explains the use of the ret instruction with a value to
add to the SP, it frees the space used by the function.  The stack is
the perfect place for all this data because each instance (each call)
of the function needs its own data, and others ways to implement it
would be really hard.

  The instruction set for call instructions is quite large in the
i8080.  It has unconditional call and ret instructions but also
conditional call and ret instructions for the Z, C, P and S flags.
Conditional calls and rets work is in the same way as conditional
jumps.  If the condition is true the instructions performs a call or a
return, if not continues the execution in the next instruction.

  An example of an implementation of a ret instruction could be:

	case 0xc9:
		PC = memory[SP];		/*  Get the return address  */
		SP +=	2;			/*  Delete the stack entry  */
	break;

  The software interrupts are a special way to call functions.  There
is a fixed range of these interrupts (usually there are 256) and those
functions are not called by an address but by an interrupt number (0
to 255 for example).  They have many uses, mainly related with OSes.
They provide a fixed way to call something: for example int 13h is the
standard call for the PC BIOS video functions.  Software interrupts
used to be vector driven.  There is a table of addresses in a special
location in the memory which contains the address for each interrupt
(which is usually located at the start of the memory space).  This table
can be modified to point to different locations (redirect the
interrupt to another routine), but those functions are always called
in the same way.  The interrupt number is the index to this table.


  Software interrupts are also used as gates to system mode and to the
OS system calls (the API provided by the OS).  They change the working
mode of the CPU to system mode.

  The instructions which make calls to software interrupts are usually
called int or trap, but they have other names.  An int instruction works
much as a call instruction but it has some differences.  The returning
address is stored in the stack as in a call instruction, but usually
the status word (the flags) is also stored on the stack with it.  The
SP is updated as usual and the PC is loaded with the value pointed to
in the vector table by the interrupt number (or with a value obtained
which is just another standard manner for obtaining interrupt addresses).
If the int is a gate to system mode then the emulator has to perform
all the changes needed in a CPU mode change (change CPU mode bits for
example, change the stack pointer to system mode pointer, etc).

  The flags are stored because it is supposed to be a kind of entry to
the OS, and therefore contexts switch.  A context switch implies to
save the entire CPU context but many CPUs just save the flags and let
everything else to the OS.  Other CPUs can save everything.

  The instruction used for returning from an interrupt (and it works
for all kind of interrupts: softs, IRQs and exceptions) can be called
iret.  Performs the same tasks than a common ret instruction but also
restores the context, that is, restores the status word or any other
information that the interrupt call saved.

  Some software interrupts have special opcodes: for example in x86
int3 has opcode 0xcc while a common interrupt has an opcode 0xcd 0xnn
where nn is the interrupt number.

  Hardware interrupts (also called IRQs) are not produced by any
instruction but from external signals (the CPU has some pins for
receiving interrupts).  But an iret kind of instruction is used at the
end of the interrupt routine to return to point the interrupt broke
the execution.

  Exceptions are produced by any kind of instruction that produces a
CPU error.  For example any memory load or store in a system with
virtual memory can produce a page fault.  Exceptions are hard to
emulate because they potentially reduce a lot the performance of the
emulator.  If each memory instruction have to check for a page fault
exception the cost can be really great.  Exceptions handling routines
are the same as soft int and IRQs routines and end with an iret
instruction.

  In some cases there are exceptions which can be generated by
specific instructions, as for example divide by zero exceptions.

  The i8080 has a non-maskable interrupt (an interrupt which can't be
disabled) and a normal interrupt for hardware signals.  I think it
doesn't have any exceptions.  There are two instructions for enabling
and disabling the hardware interrupt (INT) which are EI (enable) and
DI (disable).  The software interrupts are called with the instruction
RST.  It provides 8 different fixed position entry points for
interrupts.  There aren't special return instructions for interrupts
(because the flags aren't saved ... well I think here my documentation
is a bit uncomplete).

  I will talk about exception and interrupt emulation in another doc.

  Here ends this doc.



